[
  
  {
    "title": "International Remittance Fee Comparison Platform",
    "url": "/posts/International-Remittance-Fee-Comparison-Platform/",
    "categories": "Projects, Next.js, React",
    "tags": "react, typescript, postgresql, finanace, supabase, vercel",
    "date": "2025-12-14 22:00:00 -0500",
    





    
    "snippet": "1. Executive SummarySendFeeCompare is a remittance comparison platform designed to help users find the best rates and lowest fees when sending money between the United States and South Korea. The a...",
    "content": "1. Executive SummarySendFeeCompare is a remittance comparison platform designed to help users find the best rates and lowest fees when sending money between the United States and South Korea. The application automatically scrapes real-time exchange rates from multiple providers and presents a clear comparison of total costs including fees, exchange rate margins, and available promotions.Key Value Propositions  Real-time Rate Comparison: Automated scraping of exchange rates from 9+ providers every 3 hours  Transparent Cost Breakdown: Shows fees, exchange rate margins, and total costs in a clear format  Promotion Tracking: Displays current promotions and discounts with date-based filtering  Bi-directional Support: Supports both US→KR and KR→US transfer directions  Multi-currency Display: Shows costs in both USD and KRW for easy understanding  Multi-language Support: Full Korean and English language support  Mobile-responsive Design: Optimized for both desktop and mobile usersVision StatementTo empower individuals to make informed decisions about international money transfers by providing transparent, real-time comparisons of all available options, ultimately saving users time and money on every transfer.2. Target UsersPrimary User Persona: “Korean-American Remittance Sender”Demographics:  Age: 25-60 years old  Occupation: Professionals, business owners, students  Location: United States (with family/financial ties to Korea)  Transfer Frequency: Monthly or occasional transfersCharacteristics:  Regularly sends money to family in Korea  Compares multiple providers before each transfer  Values transparency in fees and exchange rates  Uses both English and Korean interfaces  Mobile-first browsing behavior  Price-sensitive but also values conveniencePain Points:  Exchange rates and fees vary significantly between providers  Hidden fees not apparent until checkout  Time-consuming to manually compare multiple websites  Difficulty understanding true cost of transfer  Promotions expire without notice  Language barriers with some servicesGoals:  Find the lowest total cost for each transfer  Understand exactly how much recipient will receive  Stay informed about current promotions  Make quick decisions with confidence  Save money on recurring transfersSecondary User Persona: “Korean Expat/International Student”Demographics:  Age: 20-35 years old  Location: Korea (sending money to US) or US (receiving money from Korea)  Income: Variable (students, early career)Characteristics:  Needs to send/receive money for tuition, rent, or living expenses  Very price-sensitive  Tech-savvy, expects modern web experience  Prefers Korean language interface3. Core Features3.1 Implemented Features            Feature      Description                  Provider Comparison      Compare 9+ remittance providers side-by-side              Real-time Rates      Automated scraping every 3 hours via GitHub Actions              Amount-based Rates      Different rates for different transfer amounts (6 tiers)              Fee Breakdown Modal      Detailed breakdown of all costs              Promotion Display      Current promotions with date-based filtering              Bi-directional Support      US→KR and KR→US transfers              Language Toggle      Korean/English interface              Responsive Design      Mobile and desktop optimized              Provider Links      Direct links to provider websites              Failure Alerts      Slack notifications on scraping failures      3.2 Supported Providers            Provider      Scraping Method      Notes                  Wise      API      Direct API integration              Remitly      Puppeteer      Browser automation              Xoom      Puppeteer      PayPal service              WireBarley      Puppeteer      Korean-focused service              Sentbe      Puppeteer      Korean service              Utransfer      Puppeteer      Korean service              Instarem      Puppeteer      Singapore-based              OFX      Puppeteer      Business-focused              Bank of America      Puppeteer      Traditional bank      3.3 Amount TiersUS → KR (USD):  $100, $500, $1,000, $2,000, $5,000, $10,000KR → US (KRW):  ₩100,000, ₩500,000, ₩1,000,000, ₩5,000,0004. Technology Stack4.1 Frontend            Technology      Version      Purpose                  Next.js      16.x      Full-stack React framework (App Router)              React      19.x      UI library              TypeScript      5.9.x      Type safety              Tailwind CSS      4.x      Utility-first CSS framework              Radix UI      Latest      Accessible UI primitives (Dialog, Select)              Lucide React      Latest      Icon library              Zod      4.x      Schema validation      Framework Version Rationale:  Next.js 16 with App Router: Latest stable version with improved performance, server components, and better caching  React 19: Latest features including improved server components support  Tailwind CSS v4: Significant performance improvements and new features4.2 Backend            Technology      Purpose                  Next.js API Routes      Serverless API endpoints              Supabase      PostgreSQL database with real-time capabilities              Supabase Auth      Authentication (future)      4.3 Data Collection            Technology      Purpose                  Puppeteer      Browser automation for dynamic sites              @sparticuz/chromium      Serverless-compatible Chromium              Cheerio      HTML parsing for static content      4.4 External APIs            Service      Purpose      Update Frequency                  exchangerate-api.com      Mid-market exchange rates      Every 3 hours              Provider Websites      Provider-specific rates      Every 3 hours      4.5 DevOps &amp; Infrastructure            Service      Purpose                  Vercel      Hosting and serverless functions              GitHub Actions      CI/CD and scheduled scraping              Supabase      Database hosting              Slack Webhooks      Failure notifications      5. Architecture5.1 High-Level Architecture┌─────────────────────────────────────────────────────────────────┐│                         User Browser                             ││                    (React 19 + Next.js 16)                       │└─────────────────────────────────────────────────────────────────┘                                │                                ▼┌─────────────────────────────────────────────────────────────────┐│                      Vercel Edge Network                         ││                    (CDN + Serverless Functions)                  │└─────────────────────────────────────────────────────────────────┘                                │                ┌───────────────┼───────────────┐                ▼               ▼               ▼        ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │  API Routes │ │ Static Pages│ │ Server      │        │ /api/v1/*   │ │ /privacy    │ │ Components  │        │ /api/cron/* │ │ /disclaimer │ │             │        └─────────────┘ └─────────────┘ └─────────────┘                │                ▼┌─────────────────────────────────────────────────────────────────┐│                         Supabase                                 ││          (PostgreSQL + Real-time + Storage)                      │├─────────────────────────────────────────────────────────────────┤│ Tables:                                                          ││ - providers            - provider_promotions                     ││ - provider_fees        - provider_rate_latest                    ││ - provider_rate_scrapes - mid_market_rates                       ││ - scrape_configs       - notification_logs                       │└─────────────────────────────────────────────────────────────────┘5.2 Data Flow┌──────────────────────────────────────────────────────────────────┐│                    Scheduled Data Collection                      ││                    (GitHub Actions - Every 3h)                    │└──────────────────────────────────────────────────────────────────┘                                │        ┌───────────────────────┼───────────────────────┐        ▼                       ▼                       ▼┌───────────────┐      ┌───────────────┐      ┌───────────────┐│ Mid-Market    │      │ Provider      │      │ Provider      ││ Rate API      │      │ Scrapers      │      │ Scrapers      ││ (exchangerate)│      │ (Puppeteer)   │      │ (API)         │└───────────────┘      └───────────────┘      └───────────────┘        │                       │                       │        └───────────────────────┼───────────────────────┘                                ▼                    ┌───────────────────┐                    │     Supabase      │                    │   (PostgreSQL)    │                    └───────────────────┘                                │                                ▼┌──────────────────────────────────────────────────────────────────┐│                    User Request Flow                              ││                                                                   ││  User Input → API Route → ComparisonService → Database Query     ││            → Calculate Costs → Return Results → Display UI       │└──────────────────────────────────────────────────────────────────┘5.3 Project Structuresendfeecompare-next/├── app/                          # Next.js App Router│   ├── api/                      # API Routes│   │   ├── cron/                 # Scheduled tasks│   │   │   ├── scrape-rates/     # Provider scraping│   │   │   └── update-rates/     # Mid-market rates│   │   ├── health/               # Health check│   │   └── v1/                   # Versioned API│   │       ├── admin/            # Admin endpoints│   │       ├── compare/          # Comparison API│   │       ├── providers/        # Provider list│   │       └── rates/            # Rate queries│   ├── disclaimer/               # Disclaimer page│   ├── privacy/                  # Privacy policy│   ├── transfer-info/            # Transfer info page│   ├── layout.tsx                # Root layout│   └── page.tsx                  # Home page├── components/                   # React components│   ├── ComparisonApp.tsx         # Main client component│   ├── ComparisonResults.tsx     # Results display│   ├── FeeBreakdownModal.tsx     # Detail modal│   ├── Header.tsx                # Navigation header│   ├── HeroSection.tsx           # Input section│   └── ...├── lib/                          # Business logic│   ├── i18n/                     # Internationalization│   ├── scrapers/                 # Rate scrapers│   │   ├── providers/            # Provider-specific scrapers│   │   ├── base-scraper.ts       # Abstract base class│   │   └── browser.ts            # Puppeteer utilities│   ├── services/                 # Business services│   │   ├── comparison-service.ts # Cost calculation│   │   ├── scrape-service.ts     # Scraping orchestration│   │   └── rate-service.ts       # Rate caching│   ├── supabase/                 # Database clients│   ├── types/                    # TypeScript types│   └── validations/              # Zod schemas├── public/                       # Static assets│   └── logos/                    # Provider logos├── supabase/                     # Database│   ├── migrations/               # Schema migrations│   └── seed.sql                  # Initial data├── docs/                         # Documentation└── .github/workflows/            # CI/CD pipelines6. Database Schema6.1 Core Tables            Table      Description                  providers      Provider information (name, logo, URLs)              provider_fees      Manual fee configurations              provider_promotions      Promotions with date filtering              provider_rate_latest      Current rates (UPSERT-based)              provider_rate_scrapes      Historical rate data              mid_market_rates      Reference exchange rates              scrape_configs      Scraper configurations              scrape_jobs      Scraping job history              notification_logs      Alert history      6.2 Key Relationshipsproviders (1) ─────┬───── (N) provider_fees                   ├───── (N) provider_promotions                   ├───── (N) provider_rate_latest                   └───── (N) scrape_configs7. API Endpoints7.1 Public APIs            Endpoint      Method      Description                  /api/v1/compare      POST      Calculate comparison results              /api/v1/providers      GET      List active providers              /api/v1/rates      GET      Get current rates              /api/health      GET      Health check      7.2 Admin APIs            Endpoint      Method      Description                  /api/v1/admin/scrape      POST      Trigger manual scrape              /api/v1/admin/monitoring      GET/POST      Monitoring status      7.3 Cron APIs            Endpoint      Schedule      Description                  /api/cron/scrape-rates      Every 3h      Scrape provider rates              /api/cron/update-rates      Every 3h      Update mid-market rates      8. Cost Calculation Logic1. Mid-Market Amount = Send Amount × Mid-Market Rate2. Provider Amount = Send Amount × Provider Rate3. Exchange Cost = Mid-Market Amount - Provider Amount4. Total Fee = Scraped Fee + Manual Fees5. Total Discount = Sum of applicable promotions6. Total Cost = Exchange Cost + Total Fee - Total Discount7. Received Amount = Provider Amount - Total Fee (in target currency)9. Deployment &amp; Operations9.1 Deployment PipelineGitHub Push → GitHub Actions → Build Check → Vercel Deploy                    │                    └─→ Scheduled Jobs (scrape-rates, update-rates)9.2 Environment Variables# SupabaseNEXT_PUBLIC_SUPABASE_URL=NEXT_PUBLIC_SUPABASE_ANON_KEY=SUPABASE_SERVICE_ROLE_KEY=# External APIsEXCHANGE_API_KEY=# SecurityCRON_SECRET=# NotificationsSLACK_WEBHOOK_URL=9.3 Monitoring  Scraping Failures: Slack alerts on failure  Health Checks: /api/health endpoint  Logging: Structured logs in Vercel10. Documentation Index  Note: Detailed documentation files are maintained in the project repository. For implementation details, please refer to the source code and inline comments.11. Future RoadmapPhase 1: Core Features (Completed)  Provider comparison with real-time rates  Automated scraping via GitHub Actions  Promotion tracking with date filtering  Multi-language support (KO/EN)  Slack failure notificationsPhase 2: Enhanced Features (Planned)  User accounts and saved preferences  Email alerts for rate changes  Historical rate charts  Provider reviews and ratings  Mobile app (React Native)Phase 3: Expansion (Future)  Additional corridors (e.g., US-Japan, US-China)  Business/corporate accounts  API for third-party integration  Affiliate partnershipsLast Updated: 2026-01-08Maintainer: Project OwnerCurrent Status: Production (MVP)"
  },
  
  {
    "title": "Financial Assets Management Web Application Project",
    "url": "/posts/financial-assets-management-web-application-project/",
    "categories": "Projects, ASP.NET, React",
    "tags": "dotnet, aspnet-core, react, typescript, postgresql, finance, personal-finance, portfolio",
    "date": "2025-09-19 23:00:00 -0400",
    





    
    "snippet": "1. Executive SummaryAsset-Dash is a finance web application designed to replace a Google Spreadsheet-based financial management system. The application will provide comprehensive financial tracking...",
    "content": "1. Executive SummaryAsset-Dash is a finance web application designed to replace a Google Spreadsheet-based financial management system. The application will provide comprehensive financial tracking, including asset management, investment portfolio monitoring, credit card tracking, cashflow management, budget/spending management, and long-term financial planning.It requires a robust, secure, and user-friendly platform that maintains all existing functionality while providing enhanced automation, real-time data updates, and improved visualization.Key Value Propositions:  Centralized financial dashboard with real-time net worth tracking  Automated investment portfolio updates with current market prices  Credit card management with due date reminders and benefit tracking  Budget tracking with category-based expense allocation  Long-term financial planning with age-based asset allocation glide paths  Multi-currency support (USD and KRW)  Multi-language support (English and Korean)  Enhanced data security over spreadsheetsVision StatementTo empower individuals to take complete control of their financial future through an intuitive, comprehensive, and secure personal finance platform that transforms complex financial data into actionable insights.3. Target UsersPrimary User Persona: “Financially Savvy Professional”Demographics:  Age: 25-50 years old  Occupation: Technology/Engineering professional  Income: High-income earner ($100k+ annually)  Location: United States (with international ties)Characteristics:  Manages complex financial portfolio across multiple institutions  Has both US and Korean financial accounts  Actively invests in stocks, bonds, ETFs, and cryptocurrency  Owns real estate with mortgage  Maximizes retirement accounts (401k, Roth IRA, HSA)  Uses multiple credit cards for rewards optimization  Currently uses spreadsheets or basic tools  Values data privacy and controlPain Points:  Manual spreadsheet updates are time-consuming  No real-time portfolio valuation  Difficult to track performance across multiple accounts  Risk of calculation errors in spreadsheets  No automated reminders for due dates  Limited historical analysis and trending  Concerns about spreadsheet security/backupGoals:  Track net worth in real-time  Optimize asset allocation based on age/risk tolerance  Monitor investment performance across brokerages  Stay on top of credit card due dates and limits  Maintain budget and track spending patterns  Plan for early retirement (FIRE movement)  Make data-driven financial decisions9. Technology Stack9.1 Backend (.NET)Framework:  ASP.NET Core 8.0: Latest LTS version for web API  C# 12: the version of C# that was released alongside .NET 8.Framework Version Rationale:Why .NET 8 LTS over .NET 9:  .NET 8 is LTS (Long Term Support): Supported until November 2026 (3 years)  .NET 9 is STS (Standard Term Support): Only 18 months support, ending May 2026  Stability Priority: LTS releases are battle-tested and have more mature ecosystems  Enterprise Pattern: Standard approach is to migrate LTS → LTS, skipping STS releases  No Need for Latest Features: .NET 8 provides all necessary capabilities for MVP  Avoid Double Migration: Choosing .NET 9 would require upgrading to .NET 10 within 6 monthsUpgrade Path to .NET 10 LTS:Phase 1 (Oct 2025 - Q1 2026): Build MVP on .NET 8 LTS├─ Develop core features with stable framework├─ Test and stabilize application└─ Deploy to productionPhase 2 (Q2-Q3 2026): Upgrade to .NET 10 LTS├─ Wait for .NET 10.0.3+ (mature release after Nov 2025 launch)├─ Test upgrade in development environment├─ Follow Microsoft migration guide├─ Deploy upgraded version to production└─ Benefit from 3 more years of support (until Nov 2028)This approach provides:  Maximum stability during initial development (2025-2026)  Clear one-time upgrade path to next LTS version  1-year overlap between .NET 8 and .NET 10 LTS for planned migration  No rushed upgrades or multiple migration cyclesData Access:  Entity Framework Core 8: ORM for database operations  Dapper: For complex queries requiring optimization  PostgreSQL: Primary database (recommend PostgreSQL for cost)Authentication &amp; Security:  ASP.NET Core Identity: User authentication and authorization  JWT Tokens: For API authentication  IdentityServer / Auth0: For OAuth 2.0 / OIDC (future)API Documentation:  Swashbuckle (Swagger): OpenAPI documentationBackground Jobs:  Hangfire: For scheduled tasks (price updates, reminders)  Quartz.NET: Alternative for complex schedulingCaching:  Redis / In-Memory Cache: For session management and performanceLogging &amp; Monitoring:  Serilog: Structured logging  Application Insights / Seq: Log aggregation and monitoringTesting:  xUnit: Unit testing framework  Moq: Mocking framework  FluentAssertions: Assertion library9.2 FrontendFramework:  React 18+ with TypeScript: Modern UI library with type safety  Next.js: For SSR and better SEO if neededState Management:  React Query / TanStack Query: Server state management  Zustand / Redux Toolkit: Client state managementUI Components:  Tailwind CSS: Utility-first CSS framework  shadcn/ui or Radix UI: Accessible component primitives  Chart.js / Recharts: Data visualization  date-fns: Date manipulationForms:  React Hook Form: Form state management  Zod: Schema validationHTTP Client:  Axios: HTTP requests with interceptorsBuild Tools:  Vite: Fast development server and build tool  pnpm / npm: Package management9.3 External APIsMarket Data:  Alpha Vantage: Stock and crypto prices (free tier available)  IEX Cloud: Real-time stock data  Yahoo Finance API: Alternative for price data  CoinGecko: Cryptocurrency pricesFinancial Aggregation (Future):  Plaid: Bank account aggregation  Yodlee: Alternative aggregation serviceCurrency Exchange:  exchangerate-api.com: USD/KRW conversion rates  Open Exchange Rates: AlternativeReal Estate Valuation:  Zillow API (Zestimate): Property valuation, rent estimates, and market data          Endpoint: Zillow GetSearchResults, GetZestimate, GetRentZestimate APIs      Rate Limits: 1,000 calls per day (free tier)      Data: Current home value (Zestimate), rent value (Rent Zestimate), property details, market trends      Update Frequency: Daily for property values        Redfin: Alternative real estate data and property valuations          Public data scraping or potential partnership for API access      Data: Current market value, estimated rent, days on market, property characteristics      Note: Redfin does not offer a public API; may require web scraping or third-party aggregators        Attom Data Solutions: Comprehensive property data API (commercial alternative)          Property valuations, rental estimates, tax assessments, foreclosure data      Rate Limits: Based on subscription tier      Notifications:  SendGrid / Amazon SES: Email delivery  Twilio: SMS notifications (future)9.4 DevOps &amp; InfrastructureVersion Control:  Git / GitHub: Source control and collaborationCI/CD:  GitHub Actions: Automated build and deployment  Azure DevOps: AlternativeHosting:  Azure App Service: Managed web hosting  AWS Elastic Beanstalk: Alternative  Docker: ContainerizationDatabase Hosting:  Azure SQL Database / PostgreSQL on Azure  AWS RDS: Alternative  Supabase: PostgreSQL with built-in featuresStorage:  Azure Blob Storage: For file storage and backups  AWS S3: AlternativeMonitoring:  Application Insights: Performance monitoring  Sentry: Error tracking"
  },
  
  {
    "title": "Effective Software Architecture (translation)",
    "url": "/posts/effective-software-architecture/",
    "categories": "",
    "tags": "architecture, translation, software",
    "date": "2025-03-27 11:00:00 -0400",
    





    
    "snippet": "OverviewThis is a Korean translation of Oliver Goldman’s book on effective software architecture. The translation presents practical guidance for designing, evolving and governing software systems,...",
    "content": "OverviewThis is a Korean translation of Oliver Goldman’s book on effective software architecture. The translation presents practical guidance for designing, evolving and governing software systems, covering context, change, process, design, decision-making, practices, communication, architecture teams, and product development organizations.Table of Contents  Software Architecture          1.1 Fundamental structure      1.2 Systems      1.3 Components      1.4 Relationships between components      1.5 Relationship with the environment      1.6 Principles that govern design      1.7 System evolution      1.8 Summary        Context          2.1 Concepts      2.2 Reliability      2.3 Architecturally significant requirements      2.4 Product lines              2.4.1 Single product, multiple platforms      2.4.2 Product line      2.4.3 Product family      2.4.4 Cross-platform      - 2.5 Building a platform      - 2.6 Standards      - 2.7 Summary        Change          3.1 Stages of change      3.2 Types of change      3.3 Product-driven change      3.4 Technology-driven change      3.5 Simplification      3.6 Investment mindset      3.7 Incremental deployment      3.8 Architectural evolution      3.9 Summary        Process          4.1 System documentation      4.2 Working toward a vision      4.3 Writing change proposals      4.4 Backlog management      4.5 Considering alternatives      4.6 Doing nothing      4.7 Urgency and importance      4.8 Re-documenting the system      4.9 Summary        Design          5.1 How architecture improves design efficiency      5.2 Design impact on architectural change      5.3 Decomposition      5.4 Composition      5.5 Composition and platforms      5.6 Incremental approaches      5.7 Parallelism      5.8 Organizational structure      5.9 Open work      5.10 Abandoning      5.11 Finishing      5.12 Summary        Decision Making          6.1 Is more information helpful?      6.2 What has happened so far?      6.3 How many decisions are we making?      6.4 What is the cost of doing nothing?      6.5 Can we absorb the change?      6.6 What is the cost of a wrong decision?      6.7 How much more certain can we be?      6.8 Is this decision my responsibility?      6.9 Is it consistent?      6.10 Can it be documented?      6.11 Summary        Practices          7.1 Backlog      7.2 Catalog      7.3 Templates      7.4 Reviews      7.5 Progress status      7.6 Velocity      7.7 Focus time      7.8 Summary        Communication          8.1 Mental models      8.2 Documentation      8.3 Conversation      8.4 Information architecture      8.5 Naming      8.6 Glossary      8.7 Listening      8.8 Summary        Architecture Team          9.1 Specialization      9.2 Team structure      9.3 Leadership      9.4 Responsibility      9.5 People      9.6 Diversity      9.7 Organizational culture      9.8 Meetings      9.9 Seminars and summits      9.10 Summary        Product Development Organization          10.1 Work by development methodology      10.2 Collaboration with product management              10.2.1 Helping      10.2.2 Multiple outcomes      10.2.3 Boundaries of scope        - 10.3 Collaboration with UX teams        - 10.4 Collaboration with program management        - 10.5 Collaboration with engineering teams      10.5.1 Engaging to the end        - 10.6 Collaboration with testing teams        - 10.7 Collaboration with operations teams        - 10.8 Summary      Appendix — Conclusion  A.1 Vision  A.2 Architectural recovery  A.3 Organizational change  A.4 Change process  A.5 Closing remarks"
  },
  
  {
    "title": "Shells, Terminals, and More",
    "url": "/posts/shells-terminals-and-more/",
    "categories": "MacOS, Tools",
    "tags": "bash, zsh, shell, iterm2, oh-my-zsh",
    "date": "2024-06-17 23:00:00 -0400",
    





    
    "snippet": "IntroductionIn this post, we’ll explore the fascinating world of command-line interfaces, focusing on essential tools and concepts such as shells (Bash and Zsh) and terminal emulators (iTerm2). As ...",
    "content": "IntroductionIn this post, we’ll explore the fascinating world of command-line interfaces, focusing on essential tools and concepts such as shells (Bash and Zsh) and terminal emulators (iTerm2). As developers and system administrators, these tools are crucial for efficiently interacting with our systems. We’ll dive into the reasons behind my personal choices and provide step-by-step guides on installation and configuration. So, let’s get started!About ShellsTypes of ShellsA shell is a program that provides an interface for users to interact with the operating system. It interprets commands entered by the user and executes them. Some common shells include:  Bash (Bourne-Again Shell)  Zsh (Z Shell)  Tcsh (TENEX C Shell)BashBash is the default shell on most Unix-based systems, including Linux and macOS. It is an enhanced version of the original Bourne Shell (sh) and offers a wide range of features and improvements, such as command-line editing, command history, tab completion, and shell scripting capabilities.ZshZsh is an extended version of the Bourne Shell with numerous improvements and features. It is highly customizable and provides a more powerful and interactive command-line experience compared to Bash.Why I Chose ZshI chose to use Zsh for several compelling reasons. Firstly, Zsh offers enhanced tab completion compared to Bash, making it easier to navigate and complete commands. It provides more advanced and contextual suggestions, saving time and effort. Secondly, Zsh is highly customizable, allowing me to tailor my shell experience to my preferences. I can configure various aspects of the shell, such as prompt style, color schemes, and keybindings, to create a personalized and efficient workflow. Lastly, Zsh has a rich plugin ecosystem, including the popular Oh My Zsh framework, which enables me to extend the functionality of my shell with a wide range of plugins and themes. These plugins provide additional features, shortcuts, and integrations with other tools, further enhancing my productivity.Installation and CommandsTo install Zsh on your system, follow these steps:      Check if Zsh is already installed by running zsh --version in your terminal.        If Zsh is not installed, use your package manager to install it. For example, on macOS with Homebrew, run brew install zsh.        Set Zsh as your default shell by executing chsh -s $(which zsh).        Restart your terminal or open a new session for the changes to take effect.  About TerminalsTypes of TerminalsA terminal emulator is a program that emulates a physical terminal, allowing users to interact with the shell. Some popular terminal emulators include:  Terminal (default on macOS)  iTerm2 (macOS)  GNOME Terminal (Linux)  Konsole (Linux)Iterm2iTerm2 is a feature-rich and customizable terminal emulator for macOS. It offers a superior user experience compared to the default Terminal app.Why I Chose iTerm2I chose to use iTerm2 for several reasons. iTerm2 provides a wide range of advanced features and customization options that surpass the default Terminal app on macOS. One of the key features that attracted me to iTerm2 is its ability to split the terminal window into multiple panes and tabs. This functionality allows me to work on different tasks simultaneously, greatly enhancing my multitasking capabilities and productivity. Additionally, iTerm2 offers extensive customization options, enabling me to personalize the appearance of my terminal. I can choose from a variety of themes, color schemes, and fonts to create a visually appealing and comfortable working environment. Moreover, iTerm2 integrates seamlessly with other tools and services, such as tmux and Git, providing a seamless and efficient workflow.Installation and CommandsTo install iTerm2 on macOS, follow these steps:      Visit the iTerm2 website at https://iterm2.com/.        Download the latest stable release of iTerm2.        Open the downloaded DMG file and drag the iTerm2 app to your Applications folder.        Launch iTerm2 from the Applications folder or using Spotlight search.  Other Things to KnowOh My ZshOh My Zsh is an open-source configuration management framework for Zsh. It provides a collection of plugins, themes, and configurations to enhance your Zsh shell experience. Some benefits of using Oh My Zsh include easy plugin management, a wide selection of themes, aliases and functions for common tasks, and regular updates with community contributions.Additional TipsHere are a few more tips to enhance your command-line experience:      Customize your prompt: Modify your shell prompt to display relevant information, such as the current directory, Git branch, or system status.        Learn keyboard shortcuts: Familiarize yourself with keyboard shortcuts for your shell and terminal emulator to navigate and perform actions more efficiently.        Use version control: Incorporate version control systems like Git into your workflow to track changes, collaborate with others, and manage your codebase effectively.        Explore shell scripting: Learn shell scripting to automate repetitive tasks, create custom utilities, and streamline your development process.        Continuously learn and explore: Stay curious and keep learning about new tools, techniques, and best practices in the command-line ecosystem to further enhance your skills and productivity.  ConclusionInvesting time in learning and customizing your shell and terminal setup can greatly improve your efficiency and productivity as a developer or system administrator. By choosing tools like Zsh and iTerm2, you can unlock a more powerful and enjoyable command-line experience.Remember, the key is to experiment, explore, and find the combination of tools and configurations that best suits your needs and preferences. Embrace the command-line, and let it become an indispensable ally in your daily workflows.Happy shelling!"
  },
  
  {
    "title": "Malaria Detection using Machine Learning",
    "url": "/posts/malaria-detection-using-machine-learning/",
    "categories": "Projects, Machine Learning",
    "tags": "Android, Kotlin, Java, Mobile App",
    "date": "2024-05-19 23:00:00 -0400",
    





    
    "snippet": "TechnologiesPython, TensorFlow, Keras, Scikit-learnDescriptionThis project focused on developing machine learning models to classify parasitized and uninfected cells in the malaria dataset. The pro...",
    "content": "TechnologiesPython, TensorFlow, Keras, Scikit-learnDescriptionThis project focused on developing machine learning models to classify parasitized and uninfected cells in the malaria dataset. The project was divided into three phases: data selection, model training, fine-tuning, and performance evaluation. Below is the final report that I wrote for the project.IntroductionThis report presents the collaborative efforts of our Applied Machine Learning Team Project,with a specific emphasis on the malaria dataset comprising blood smear images. The datasetconsists of approximately 27,558 images, offering a balanced representation of cells infectedwith parasites and uninfected cells, thus providing an ideal challenge for developing advancedimage classification models. Our project aims to apply various machine learning algorithms tothe malaria dataset and improve model performance through data preprocessing andhyperparameter fine-tuning.We structured our project into three distinct phases. In Phase 1, we focused on dataset selection,implementing three initial models, and assessing their performance. Phase 2 involved selectingtwo initial models for further refinement, modifying their architectures, and adjustinghyperparameters to enhance performance. During Phase 3, we concentrated on conductingadditional fine-tuning tests and synthesizing our findings to create a final presentationsummarizing our research journey and the practical implications of our work.Data Analysis and Pre-Processing1) Dataset OverviewThe malaria dataset is essential for automating the detection of parasitic infections through imageanalysis. It comprises thin blood smear slide images categorized as either ‘Parasitized’ or‘Uninfected.’ This dataset, obtained from a public repository, consists of roughly 27,558 images,offering a wealth of data for developing machine learning applications in medical diagnostics.Malaria Dataset2) Statistical AnalysisWe performed a thorough statistical analysis to understand the dataset’s characteristics better. Wecalculated various metrics, such as mean pixel values and pixel value standard deviations, to gaininsights into the data distribution within the images. This analysis revealed valuable informationabout the image characteristics, including the contrast between parasitized and uninfected cells.These findings informed our subsequent preprocessing steps and model selection.The distribution of mean pixel values in the dataset was between 60 and 160, with a peak around130, suggesting that most images have similar brightness levels. The distribution of pixel value standard deviations ranged from 60 to 90, with a peak near 75, indicating that the majority ofimages have comparable levels of pixel value variability or contrast.These findings influenced our preprocessing steps in several ways. The relatively narrow rangeof mean pixel values allowed us to use a simple normalization technique, such as Min-Maxscaling, to standardize the brightness levels across images, streamlining our preprocessingpipeline. Additionally, the concentrated distribution of pixel value standard deviations suggestedthat the visual differences between infected and uninfected cells might be subtle. To address this,we employed data augmentation techniques like rotations and flips to introduce more variabilityinto our training data, helping to prevent overfitting and improve the generalization ability of ourmodels.The statistical analysis also provided valuable insights for model selection. The similarity inbrightness and contrast levels among images hinted that the distinguishing features betweeninfected and uninfected cells could lie in the local patterns and textures within the images. Thisled us to choose Convolutional Neural Networks (CNNs) as our primary model architecture, asthey are particularly well-suited for capturing intricate details and subtle changes within the cellsthrough convolutional layers, enabling effective classification of cell infection status. In additionto CNNs, we also decided to implement and test various other models learned in this course,including KNN and an ensemble model combining CNN and Decision Tree, to explore theirperformance on our dataset.3) Preprocessing StepsThe preprocessing of the dataset involved several steps to ensure the data was conducive topractical model training:      Image Normalization: Each image’s pixel values were scaled from 0 to 1. This normalizationprocess was crucial for reducing computational complexity and improving the model’sconvergence speed during training. By standardizing the pixel values across all images, weensured that the models could focus on learning the relevant patterns and features without beinginfluenced by variations in image brightness or scale.        Data Augmentation: Augmentation techniques were employed to enhance the model’sgeneralization capabilities and prevent overfitting. These techniques included rotations, flips,zooms, and shifts, which artificially increased the diversity of the training data without requiringadditional original images.        Data Splitting: The dataset was divided into training and validation sets, with 70% of the dataallocated for training and 30% reserved for validation. This split was critical for evaluating the model’s performance and fine-tuning its hyperparameters without compromising its ability togeneralize to new, unseen data.  Model StructureBuilding upon the insights gathered from our data analysis and preprocessing steps, we carefullyselected and refined our machine learning models to effectively classify parasitized anduninfected cells in the malaria dataset. Our model selection process was divided into threephases, each focusing on different model development and optimization aspects.1) Initial Model Selection in Phase 1In the first phase of our project, we implemented three distinct machine-learning models toexplore their performance on the malaria dataset:Convolutional Neural Network (CNN): We chose a CNN as our primary model due to itsproven effectiveness in image recognition tasks. The CNN architecture consisted ofconvolutional layers to capture spatial hierarchies of features, pooling layers to reducedimensionality, and fully connected layers for classification. The decision to use a CNN wasbased on its ability to automatically learn and extract relevant features from the images, which isparticularly useful given the subtle visual differences between parasitized and uninfected cells, asrevealed by our statistical analysis.K-Nearest Neighbors (KNN): We also implemented a KNN classifier to compare the CNN’sperformance with a simpler model. KNN classifies images based on the majority vote of their knearest neighbors in the feature space. While KNN is known for its simplicity and efficiency inmany classification tasks, it might struggle to capture the complex patterns in the malaria dataset,as suggested by the concentrated distributions of pixel values and standard deviations.Ensemble Model (CNN and Decision Tree): To potentially leverage the strengths of differentmodel architectures, we created an ensemble model combining a CNN and a Decision Treeclassifier. The rationale behind this choice was to investigate whether CNN’s ability to learn localpatterns and the Decision Tree’s global feature analysis could complement each other andimprove overall performance. We implemented the ensemble using a soft voting technique,which averages the prediction probabilities from both models to determine the final class label.2) Model Refinement in Phase 2Based on the results and insights from Phase 1, we selected the CNN and the Ensemble modelfor further refinement in Phase 2. Our goal was to optimize these models by fine-tuninghyperparameters, modifying architectures, and exploring advanced ensemble techniques:Enhanced CNN (VGG): To improve CNN’s performance, we transitioned to a more complexVGG architecture, which incorporates multiple convolutional and pooling layers to capture morenuanced patterns in the images. This decision was motivated by CNN’s promising initial resultsand the potential of deeper networks to distinguish the subtle differences between parasitized anduninfected cells, as indicated by our statistical analysis.Ensemble Model (CNN, Random Forest, and SVM): We refined the ensemble model byreplacing the Decision Tree with a combination of Random Forest and Support Vector Machine(SVM) classifiers. The Random Forest was chosen for its ability to handle high-dimensional dataand reduce overfitting, while the SVM was selected for its robustness in classification tasks.Additionally, we shifted from soft voting to a stacking approach, where a meta-learner is trainedon the predictions of the base models to make the final classification decision. This modificationaimed to capture more complex relationships between the models’ outputs and improve theensemble’s overall performance.3) Model Refinement in Phase 3In our project’s third and final phase, we focused on further fine-tuning our models based on theresults and insights from Phase 2. Our primary goal was to explore additional techniques toenhance the performance of our VGG and ensemble models.For the VGG model, we experimented with various hyperparameter adjustments, such asmodifying the learning rate, batch size, and number of epochs. However, despite these efforts,we observed minimal improvements in the VGG model’s performance compared to Phase 2.Similarly, for the ensemble model, we explored integrating additional machine learningalgorithms, such as Gradient Boosting, to further enhance its predictive power. We alsoexperimented with different stacking configurations and meta-learning algorithms to optimizethe combination of base models. Despite these attempts, the ensemble model’s performance wassimilar to the results obtained in Phase 2.Results and Model ComparisonHaving developed and refined our machine learning models across three phases, we nowcomprehensively analyze their performance and compare their results. This section will detail theevaluation metrics for each model, discuss the improvements achieved through modelrefinement, and provide a final assessment of our models’ effectiveness in classifying parasitizedand uninfected cells in the malaria dataset.1) Phase 1 Results and ComparisonIn Phase 1, we implemented three initial models - a CNN, KNN, and an Ensemble of CNN andDecision Tree - and evaluated their performance using various metrics, including accuracy,precision, recall, and F1-score.Model #1 (CNN): The CNN demonstrated strong performance in Phase 1, achieving an accuracyof 95.46%, precision of 94.73%, recall of 96.27%, and an F1-score of 95.49%. These resultsvalidated our choice of using a CNN for this image classification task and confirmed its ability tolearn and extract relevant features from the malaria dataset effectively.Model #2 (KNN): As anticipated based on our statistical analysis, the KNN classifier struggledto capture the complex patterns in the malaria dataset, resulting in lower performance comparedto the CNN. It achieved an accuracy, precision, recall, and F1-score of 62%. Whilecomputationally efficient, the KNN’s simplicity was a limitation in this context.Model #3 (Ensemble of CNN and Decision Tree): The ensemble model, combining a CNN andDecision Tree, aimed to leverage the strengths of both models. It achieved an accuracy of84.52%, a precision of 94.50%, a recall of 73.28%, and an F1-score of 82.55%. Although theensemble showed promising results, the lower recall indicated room for improvement indetecting all positive cases.2) Phase 2 Results and ComparisonBuilding upon the insights from Phase 1, we refined our models in Phase 2 by enhancing theCNN architecture and exploring more advanced ensemble techniques.Model #1 (VGG): The transition from a basic CNN to the VGG architecture yielded significantperformance improvements. The VGG model achieved an accuracy of 97.39%, a precision of95.52%, a recall of 97.52%, and an F1-score of 95.48%. These results demonstrated the benefitsof using a deeper network to capture more intricate patterns in the malaria dataset, as suggestedby our statistical analysis.Model #2 (Ensemble of CNN, RF, SVM): By incorporating Random Forest and SVMclassifiers into the ensemble and adopting a stacking approach, we observed notableenhancements in the model’s performance. The refined ensemble achieved an accuracy of92.86%, a precision of 91.70%, a recall of 94.23%, and an F1-score of 92.95%. Thisimprovement highlighted the effectiveness of combining diverse models and using moresophisticated ensemble techniques to make accurate predictions.Comparison with Pre-Existing Model (MobileNet): To benchmark our models’ performance,we compared them against MobileNet, a well-established efficient model. While MobileNetachieved an accuracy of 91.35%, precision of 88.46%, and recall of 95.08%, our VGG andrefined ensemble models outperformed it in terms of precision and accuracy, validating theeffectiveness of our model selection and refinement process.Training and Inference Time: The VGG model required a considerable amount of trainingtime, approximately 1246 seconds, with an inference time of 759 seconds, due to thecomputational demands of its deep neural network architecture. The ensemble model, on theother hand, had a training time of 633 seconds, and its inference time was the shortest among thethree models, at 41 seconds. Although the ensemble model showed lower performance metricssuch as accuracy, it demonstrated advantages in training and inference times, highlighting itsefficiency.3) Final ResultsThe progression from Phase 1 to Phase 2 demonstrated significant improvements in our models’performance, showcasing the impact of our refinement strategies. The VGG model, in particular,exhibited remarkable enhancements across all evaluation metrics, with accuracy increasing from95.46% to 97.39%, precision from 94.73% to 95.52%, recall from 96.27% to 97.52%, andF1-score from 95.49% to 95.48%. These results highlight the VGG model’s superior ability toanalyze and classify complex image features in the malaria dataset.Similarly, the refined ensemble model (CNN, RF, SVM) showed substantial improvements, withaccuracy increasing from 84.52% to 92.86%, precision from 94.50% to 91.70%, recall from73.28% to 94.23%, and F1-score from 82.55% to 92.95%. The integration of RF and SVMclassifiers enhanced the model’s robustness and reduced false negatives, which is crucial inmedical diagnostic applications.Conclusion1) Summary of Key Findings and LearningsThroughout this project, we explored applied machine-learning techniques to classify parasitizedand uninfected cells in the malaria dataset. Our journey yielded several key findings and valuablelearnings:Firstly, the statistical analysis of the dataset provided crucial insights into the imagecharacteristics, guiding our preprocessing steps and model selection process. The relativelynarrow distribution of mean pixel values and standard deviations suggested the need for simplenormalization techniques and highlighted the potential challenges in distinguishing betweeninfected and uninfected cells.Secondly, our iterative model selection and refinement process demonstrated the importance ofmatching model complexity to the task at hand. The superior performance of the VGG model,with its deep architecture, showcased the effectiveness of convolutional neural networks (CNNs)in capturing intricate patterns and subtle differences in the malaria dataset. This findingunderscores the remarkable capacity of CNNs for image-based classification tasks.Moreover, the development and refinement of the ensemble models revealed the potential ofcombining diverse classifiers to improve prediction reliability. The integration of Random Forestand Support Vector Machine classifiers into the ensemble, along with the adoption of a stackingapproach, resulted in enhanced robustness and reduced false negatives.2) Potential Improvements and Future Research DirectionsWhile our project achieved significant milestones, several avenues remain for furtherenhancement and exploration. One promising direction is to expand the scope of dataaugmentation techniques and incorporate higher-quality images into our training pipeline. Byapplying advanced augmentation methods, such as elastic transformations, random cropping, andcolor jittering, we can simulate a broader range of variations in the dataset, potentially improvingmodel generalization and robustness to real-world scenarios. These techniques can help ourmodels learn more diverse representations of the malaria-infected cells and adapt to thechallenges posed by variations in image quality and acquisition conditions.Another exciting avenue for future research is the investigation of advanced architectures,particularly Vision Transformers (ViT). ViTs have recently gained significant attention in thecomputer vision community due to their ability to capture long-range dependencies and globalcontext in image data. By leveraging the self-attention mechanism, ViTs can effectively modelthe relationships between different regions of an image, potentially uncovering subtle patternsand discriminative features that may be overlooked by traditional convolutional architectures.Incorporating ViTs into our model selection process could offer new perspectives on analyzingthe malaria dataset and improve our models’ ability to classify parasitized and uninfected cellsaccurately. Furthermore, exploring more advanced ensemble techniques, such as boosting ormore sophisticated stacking approaches, could enhance the performance of our ensemble models,allowing them to leverage the strengths of individual classifiers better and make more accuratepredictions.References  TensorFlow. (2023). TensorFlow Documentation: Image Classification.https://www.tensorflow.org/tutorials/images/classification  Keras. (2023). Keras Applications. https://keras.io/api/applications/  Malaria Dataset (TFDS): https://www.tensorflow.org/datasets/catalog/malaria  MobileNet (tf.keras.applications.MobileNet):https://www.tensorflow.org/api_docs/python/tf/keras/applications/MobileNet"
  },
  
  {
    "title": "Banking Web Applications Project",
    "url": "/posts/banking-web-applications/",
    "categories": "Projects, Next.js",
    "tags": "Next.js, TypeScript, TailwindCSS",
    "date": "2024-03-18 23:00:00 -0400",
    





    
    "snippet": "DescriptionDeveloped a comprehensive banking web application as a freelance project, integrating advanced features such as ultra-secure SSR authentication, multi-bank account linking using Plaid, a...",
    "content": "DescriptionDeveloped a comprehensive banking web application as a freelance project, integrating advanced features such as ultra-secure SSR authentication, multi-bank account linking using Plaid, and real-time updates across all pages. The application provides users with a detailed overview of their accounts, including total balances, recent transactions, and categorized spending. Users can view all connected banks, filter transaction history, and transfer funds using Dwolla. The application is fully responsive, ensuring a consistent user experience across all devices, and emphasizes code architecture and reusability for maintainability.TechnologiesNext.js, TypeScript, Appwrite, Plaid, Dwolla, React Hook Form, Zod, TailwindCSS, Chart.js, ShadCNFeaturesSecure Authentication and Account ManagementThis banking web application features ultra-secure SSR authentication with proper validations and authorization, ensuring that users’ accounts are protected at all times. It also integrates with Plaid, allowing users to link multiple bank accounts seamlessly. Additionally, the application provides a comprehensive view of all connected banks, displaying respective balances and account details in one place for easy management.User Account Overview and Transaction ManagementThe home page of the application gives users a general overview of their accounts, showing the total balance from all connected banks, recent transactions, and money spent across different categories. The transaction history feature includes pagination and filtering options, enabling users to view and manage their transaction history across various banks effectively. Real-time updates ensure that any changes, such as connecting new bank accounts, are immediately reflected across all relevant pages.Funds Transfer and ResponsivenessUsers can transfer funds effortlessly using Dwolla, with the application facilitating transfers to other accounts by providing required fields and recipient bank ID. The application is designed to be fully responsive, adapting seamlessly to various screen sizes and devices. This ensures a consistent and smooth user experience whether accessed on a desktop, tablet, or mobile platform.References  Next.js Documentation  TypeScript Documentation  Appwrite Documentation  Plaid API Documentation  Dwolla API Documentation  React Hook Form Documentation  Zod Documentation  TailwindCSS Documentation  Chart.js Documentation  ShadCN Documentation"
  },
  
  {
    "title": "English for Developers",
    "url": "/publications/2024-02-20-english-for-developers/",
    "categories": "",
    "tags": "english, developers, book",
    "date": "2024-02-19 10:00:00 -0500",
    





    
    "snippet": "Short descriptionThis book is a practical guide for software developers to improve their English skills for career growth, technical collaboration, and communication. It covers foundational vocabul...",
    "content": "Short descriptionThis book is a practical guide for software developers to improve their English skills for career growth, technical collaboration, and communication. It covers foundational vocabulary and grammar tailored for developers, practical expressions across software development stages, field-specific terminology, business English, graduate school application guidance, interview preparation, and an appendix dictionary for developers.Full Table of Contents (summary)CHAPTER 0 — Do Developers Need to Be Good at English?  English as Important as Coding Skills  Differences Between General English and IT/Developer English  How Much Developer English Is Enough?  Book Structure and Learning StrategiesCHAPTER 1 — Basic Preparation for Learning Developer English  Basic Vocabulary for Developers  Basic Grammar for Developers  Developer English Study TipsCHAPTER 2 — Practical English for Software Development Stages  Requirements Analysis  Design Phase  Implementation  Testing  Deployment and MaintenanceCHAPTER 3 — Practical English by Development Area  Frontend Development English  Backend Development English  Other Development Areas (DevOps, Security, Embedded, AI/ML)CHAPTER 4 — Business English for Developers  Writing Professional Emails  English for Developer Meetings  Developer PresentationsCHAPTER 5 — English for US Graduate School (Computer Engineering)  Is an Overseas Degree Needed?  How to Apply to US CS Graduate Programs  TOEFL and GRE PreparationCHAPTER 6 — English for International Developer Job Search  Basic Interview Expressions  Behavioral Interviews (STAR)  Technical InterviewsAPPENDIX A — English Dictionary for DevelopersIf you want, I can expand this page with sample excerpts, practice exercises, or a cover image file.title: English for Developersoriginal_author: Oliver Goldmantranslator: Justin (Heechul) Choipublisher: Gilbeot (길벗)date: 2024-02-20layout: 340 pagecover_image: /assets/img/publications/english-for-developers.jpgisbn: “9791140708581”E-Book Link: https://product.kyobobook.co.kr/detail/S000212263991—OverviewThis book is a practical guide for software developers who want to improve their English for career growth, collaboration, and technical communication. It covers foundational vocabulary and grammar tailored for developers, practical expressions for each stage of software development, field-specific terminology (frontend, backend, DevOps, security, embedded, and AI/ML), business English for meetings and emails, graduate school application guidance, interview preparation, and a developer-focused English dictionary.Table of ContentsCHAPTER 0 — Do Developers Need to Be Good at English?  English as Important as Coding Skills          01 Salary differences between US developers and domestic developers      02 English: opportunities for career growth      03 Tools to become a better developer        Differences Between General English and IT/Developer English          01 Differences in vocabulary and terminology      02 Differences in grammar and communication style        How Much Developer English Is Enough?          01 English for improving development skills      02 English for participating in open source communities      03 English for working abroad as a developer        Book Structure and Learning Strategies          01 Chapter-by-chapter structure      02 Study strategies for developer English      CHAPTER 1 — Basic Preparation for Learning Developer English  Basic Vocabulary for Developers          01 Frequently used verbs in developer English      02 Frequently used developer words      03 Basic pronunciation and word stress        Basic Grammar for Developers          01 Grammar for expressing the future      02 Past tense constructions      03 Present tense constructions      04 Conditionals and hypothetical forms      05 Comparatives and superlatives      06 Passive voice      07 Gerunds and infinitives      08 Prepositions      09 Articles        Developer English Study Tips          01 Reading &amp; listening practice for developers      02 Writing &amp; speaking practice for developers      CHAPTER 2 — Practical English for Software Development Stages  Requirements Analysis          01 Terminology used in requirements analysis      02 Typical questions developers receive during analysis        Design Phase          01 Design-phase terminology      02 Questions developers receive in design discussions        Implementation          01 Implementation-phase terminology      02 Git-related English expressions      03 Writing code comments        Testing          01 Testing-related terminology      02 Test case naming conventions        Deployment and Maintenance          01 Deployment and maintenance terminology      02 Writing entries in issue-tracking systems      03 English expressions for system incidents and failures      CHAPTER 3 — Practical English by Development Area  Frontend Development English          01 Web frontend development      02 Mobile application development        Backend Development English          01 Backend programming English      02 Database-related English      03 Algorithms and data structures English        Other Development Areas          01 DevOps-related vocabulary and expressions      02 Security-related vocabulary and expressions      03 Embedded systems vocabulary and expressions      04 AI / Machine Learning vocabulary and expressions      CHAPTER 4 — Business English for Developers  Writing Professional Emails          01 Scheduling and meeting requests      02 Progress and status reporting      03 Responding to incidents and outages        English for Developer Meetings          01 Meeting-related terminology      02 Language for facilitating and participating in meetings      03 Video-conference English        Developer Presentations          01 Presentation openings      02 Presenting the main content (app overview, architecture)      03 Presentation closings      CHAPTER 5 — English for US Graduate School (Computer Engineering)  Do Developers Need an Overseas Degree?          01 Advantages of an overseas graduate degree      02 Costs and planning        How to Apply to US CS Graduate Programs          01 Preparing an application as a developer      02 Required documents and submission process        TOEFL and GRE Preparation          01 TOEFL strategies and tips      02 GRE strategies and tips      CHAPTER 6 — English for International Developer Job Search  Basic Interview Expressions          01 Expressions to start an interview      02 Self-introduction      03 Explaining motivation and selling points      04 Closing an interview and thank-you messages        Behavioral Interviews          01 The STAR technique      02 Common behavioral questions and preparation        Technical Interviews          01 Clarifying the problem and explaining approach      02 Writing code and testing      03 Time &amp; space complexity analysis and optimization      APPENDIX A — English Dictionary for Developers"
  },
  
  {
    "title": "Android Car Management App Project",
    "url": "/posts/android-car-management-app/",
    "categories": "Projects, Android",
    "tags": "Android, Kotlin, Java, Mobile App",
    "date": "2022-12-18 22:00:00 -0500",
    





    
    "snippet": "DescriptionThis car maintenance app will help people keep track of their car maintenance history. And the app will give reminder based on the specific car model and car maintenance history. Also, y...",
    "content": "DescriptionThis car maintenance app will help people keep track of their car maintenance history. And the app will give reminder based on the specific car model and car maintenance history. Also, you can see a bar chart that shows current year’s monthly fuel consumption amount of your car.TechnologiesKotlin, Java, Android SDK, Room Database, Firebase, MPAndroidChartApp ArchitecutreFeatures1. Login / Register / LogoutLogin / Register / LogoutLogout2. Home (Select My Car)Select My Car3. HistoryAdd dataAdd dummy data for test4. StatisticsStatistics and Bar Chart5. ReminderSet RemindersAlter RemindersTarget Android API  Target Android API: 32 (min API 26)References  https://firebase.google.com/docs/auth  https://firebase.google.com/docs/auth/android/email-link-auth  https://github.com/PhilJay/MPAndroidChart"
  }
  
]

